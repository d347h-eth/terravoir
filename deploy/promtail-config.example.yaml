server:
  http_listen_port: 0
  grpc_listen_port: 0

clients:
  - url: https://<your-grafana-cloud-logs-host>/loki/api/v1/push
    # For Grafana Cloud, use basic auth: username is your stack/instance ID (or tenant), password is the API token
    basic_auth:
      username: <GC_LOKI_USERNAME>
      password: <GC_LOKI_PASSWORD>

positions:
  filename: /positions/positions.yaml

scrape_configs:
  - job_name: docker-indexer
    docker_sd_configs:
      - host: unix:///var/run/docker.sock
        refresh_interval: 5s
    relabel_configs:
      # Keep only the indexer service logs
      - source_labels: [__meta_docker_container_label_com_docker_compose_service]
        regex: indexer
        action: keep
      # Set a static label for service
      - source_labels: [__meta_docker_container_label_com_docker_compose_service]
        target_label: service
      # Point promtail at the container JSON log file
      - source_labels: [__meta_docker_container_id]
        target_label: __path__
        replacement: /var/lib/docker/containers/$1/$1-json.log

    pipeline_stages:
      # Unwrap Docker JSON and use `.log` as the line
      - docker: {}
      # Parse the app's JSON log
      - json:
          expressions:
            component: component
            level: level
            message: message
            ts: timestamp
      # Promote parsed fields to labels
      - labels:
          component:
          level:
      # Truncate overlong entries without using large regex quantifiers (RE2 limit)
      # If message length > 240000, cut to first 240000 chars
      - template:
          source: message
          template: '{{ if gt (len .message) 240000 }}{{ substr 0 240000 .message }}{{ else }}{{ .message }}{{ end }}'
      # Set the log line to the (possibly truncated) message field
      - output:
          source: message
      # Use the app-provided timestamp if present
      - timestamp:
          source: ts
          format: 2006-01-02 15:04:05.000
          location: UTC
